// Generated by CoffeeScript 1.9.3
(function() {
  var Token, error, lex, next_token, presets, tokens;

  error = require('./error.js');

  Token = (function() {
    function Token(type, value, line) {
      this.type = type;
      this.value = value;
      this.at_line = line;
    }

    return Token;

  })();

  presets = {
    replace_whitespace: ['\\s', 'g', ''],
    replace_whitespace_before: ['^\\s*', '', ''],
    make_spaces_single: ['\\s\\s*', 'g', ' ']
  };

  tokens = {
    'line_break': {
      match: '\\s*\\n\\n*',
      replace: [presets.replace_whitespace]
    },
    'block_end': {
      eol: true,
      sol: true
    },
    'include': {
      match: '\\s*@include',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: true
    },
    'comment': {
      match: '\\s*#.*',
      replace: [],
      eol: true,
      sol: false
    },
    'block_continue': {
      match: '\\s*(?:else[ \\t]*if|else)',
      replace: [presets.replace_whitespace_before, presets.make_spaces_single],
      eol: true,
      sol: true
    },
    'block_start': {
      match: '\\s*(?:if|for|while|until|function|method|\\->)',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: true
    },
    'keyword': {
      match: '\\s*(?:return|break|in|of)',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: true
    },
    'boolean': {
      match: '\\s*(?:true|false)',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: true
    },
    'function_call': {
      match: '\\s*[a-zA-Z]+\\(',
      replace: [presets.replace_whitespace, ['\\($', '', '']],
      eol: false,
      sol: true
    },
    'array_call': {
      match: '\\s*[a-zA-Z]+\\[',
      replace: [presets.replace_whitespace, ['\\[$', '', '']],
      eol: false,
      sol: true
    },
    'variable': {
      match: '\\s*@?[a-zA-Z_]+',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: true
    },
    'open_curly': {
      match: '\\s*\\{',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: true
    },
    'close_curly': {
      match: '\\s*\\}',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: false
    },
    'open_parinthesis': {
      match: '\\s*\\(',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: true
    },
    'close_parinthesis': {
      match: '\\s*\\)',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: false
    },
    'open_brackets': {
      match: '\\s*\\[',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: true
    },
    'close_brackets': {
      match: '\\s*\\]',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: false
    },
    'comma': {
      match: '\\s*,',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: false
    },
    'range_seperator': {
      match: '\\s*\\.\\.\\.',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: false
    },
    'binary_operator': {
      match: '\\s*(?:' + '\\|\\||\\||\\&\\&|\\&|' + '==|\\:=|\\+=|-=|\\*=|/=|%=|\\.=|=|' + '<<|>>|\\^|' + '!=|>=|<=|>|<|' + '\\*\\*|\\+|-|\\*|\\/|%|\\.|' + '\\:{1,2})',
      replace: [presets.replace_whitespace],
      eol: false,
      sol: false
    },
    'number': {
      match: '\\s*[0-9]+(?:\\.[0-9]*)?(?:e-?[0-9]*)?',
      replace: [presets.replace_whitespace],
      eol: true,
      sol: true
    },
    'string': {
      match: '\\s*\\"[^\\"\\\\]*(?:\\\\.[^\\"\\\\]*)*\\"',
      replace: [presets.replace_whitespace_before, ['^"|"$', 'g', '']],
      eol: true,
      sol: true
    }
  };

  next_token = function(code) {
    var match, reg, token;
    for (token in tokens) {
      reg = new RegExp('^' + tokens[token].match);
      match = code.match(reg);
      if (match) {
        break;
      }
    }
    return token;
  };

  lex = function(code) {
    var ends, found, i, indents, j, k, l, len, len1, line, lines, match, new_indents, ref, ref1, reg, reg2, res, starts, token;
    code = code.replace(/\s*$/, '');
    lines = (code.match(/\n/g) || []).length;
    res = [];
    indents = 0;
    while (code.length > 0) {
      token = next_token(code);
      reg = new RegExp('^' + tokens[token].match);
      match = code.match(reg);
      line = lines - (code.match(/\n/g) || []).length + 1;
      if (match === null) {
        throw error('unexpected token on line ' + line + ': ' + code.slice(0, 10).replace(/\n/, ' ') + '...');
      }
      match = match.toString();
      if (tokens[token].replace) {
        ref = tokens[token].replace;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          reg2 = new RegExp(i[0], i[1]);
          match = match.replace(reg2, i[2]);
        }
      }
      found = new Token(token, match, line);
      res.push(found);
      code = code.replace(reg, '');
      if (token === 'line_break') {
        if (!(tokens[res[res.length - 2].type].eol && tokens[next_token(code)].sol)) {
          res.pop();
          continue;
        }
      }
      if (token === 'line_break') {
        new_indents = code.match(/^\t*/).toString().length;
        if (new_indents < indents) {
          for (i = k = 0, ref1 = indents - new_indents; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            res.push(new Token('block_end', '', line));
          }
        }
        indents = new_indents;
      }
    }
    if (res[res.length - 1].type !== 'line_break' && res[res.length - 1].type !== 'block_end') {
      res.push(new Token('line_break', '', line));
    }
    starts = 0;
    ends = 0;
    for (l = 0, len1 = res.length; l < len1; l++) {
      i = res[l];
      if (i.type === 'block_start' || i.type === 'block_continue') {
        starts++;
      }
      if (i.type === 'block_end') {
        ends++;
      }
    }
    while (ends < starts) {
      ends++;
      res.push(new Token('block_end', '', line));
    }
    i = 0;
    while (i < res.length) {
      if (res[i].type === 'comment') {
        res.splice(i, 1);
      } else {
        i++;
      }
    }
    return res;
  };

  module.exports = lex;

}).call(this);

// Generated by CoffeeScript 1.9.3

/*
 * This file parses tokenized code into an abstract syntax tree.
 * It's pretty complicated.
 */

(function() {
  var ArrayCall, ArrayLiteral, BinaryExpression, Block, CLOSERS, Constant, ForLoop, FunctionCall, FunctionDefine, IfStatment, Include, Node, OPENERS, OPERATORS, Return, SingleIf, Variable, WhileLoop, binary_expression, clone, error, get_all_params, get_next_block, get_next_line, get_next_param, is_one_array, is_one_array_call, is_one_function_call, operation_importance, parse, parse_array, parse_block, parse_function_call, parse_value, print_parsed, remove_line_breaks,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  print_parsed = require('./print-parsed.js');

  error = require('./error.js');

  OPENERS = ['open_parinthesis', 'open_brackets', 'function_call', 'array_call'];

  CLOSERS = ['close_parinthesis', 'close_brackets'];

  OPERATORS = [['=', ':=', '+=', '-=', '*=', '/=', '%=', '.='], ['^'], ['&&', '&'], ['||', '|'], ['>', '<', '==', '!=', '>=', '<=', '~~'], ['.'], ['<<', '>>'], ['+', '-'], ['*', '/', '%'], ['**'], [':', '::']];

  operation_importance = function(op) {
    var i, j, ref;
    for (i = j = 0, ref = OPERATORS.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (OPERATORS[i].includes(op)) {
        return i;
      }
    }
  };

  clone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };

  Node = (function() {
    function Node(type, line) {
      this.type = type;
      this.line = line;
    }

    return Node;

  })();

  Include = (function(superClass) {
    extend(Include, superClass);

    function Include(line, name) {
      Include.__super__.constructor.call(this, 'include', line);
      this.name = name;
    }

    return Include;

  })(Node);

  Block = (function(superClass) {
    extend(Block, superClass);

    function Block(line) {
      Block.__super__.constructor.call(this, 'block', line);
      this.children = [];
    }

    return Block;

  })(Node);

  IfStatment = (function(superClass) {
    extend(IfStatment, superClass);

    function IfStatment(line) {
      IfStatment.__super__.constructor.call(this, 'if', line);
      this.blocks = [];
    }

    return IfStatment;

  })(Node);

  SingleIf = (function(superClass) {
    extend(SingleIf, superClass);

    function SingleIf(line) {
      SingleIf.__super__.constructor.call(this, 'single-if', line);
      this.test = false;
      this.block = false;
    }

    return SingleIf;

  })(Node);

  WhileLoop = (function(superClass) {
    extend(WhileLoop, superClass);

    function WhileLoop(line) {
      WhileLoop.__super__.constructor.call(this, 'while', line);
      this.test = false;
      this.block = false;
    }

    return WhileLoop;

  })(Node);

  ForLoop = (function(superClass) {
    extend(ForLoop, superClass);

    function ForLoop(line) {
      ForLoop.__super__.constructor.call(this, 'for', line);
      this.variable = false;
      this.start = false;
      this.end = false;
      this.step = 1;
      this.block = false;
    }

    return ForLoop;

  })(Node);

  FunctionDefine = (function(superClass) {
    extend(FunctionDefine, superClass);

    function FunctionDefine(line) {
      FunctionDefine.__super__.constructor.call(this, 'function-define', line);
      this.name = false;
      this.params = [];
      this.block = false;
    }

    return FunctionDefine;

  })(Node);

  Return = (function(superClass) {
    extend(Return, superClass);

    function Return(line) {
      Return.__super__.constructor.call(this, 'return', line);
      this.block = false;
    }

    return Return;

  })(Node);

  FunctionCall = (function(superClass) {
    extend(FunctionCall, superClass);

    function FunctionCall(line) {
      FunctionCall.__super__.constructor.call(this, 'function-call', line);
      this.name = false;
      this.params = [];
    }

    return FunctionCall;

  })(Node);

  BinaryExpression = (function(superClass) {
    extend(BinaryExpression, superClass);

    function BinaryExpression(line, operator) {
      BinaryExpression.__super__.constructor.call(this, 'binary_expression', line);
      this.operator = operator;
      this.left = false;
      this.right = false;
    }

    return BinaryExpression;

  })(Node);

  ArrayLiteral = (function(superClass) {
    extend(ArrayLiteral, superClass);

    function ArrayLiteral(line) {
      ArrayLiteral.__super__.constructor.call(this, 'array_literal', line);
      this.items = [];
    }

    return ArrayLiteral;

  })(Node);

  ArrayCall = (function(superClass) {
    extend(ArrayCall, superClass);

    function ArrayCall(line) {
      ArrayCall.__super__.constructor.call(this, 'array_call', line);
      this.name = false;
      this.index = false;
    }

    return ArrayCall;

  })(Node);

  Variable = (function(superClass) {
    extend(Variable, superClass);

    function Variable(line) {
      Variable.__super__.constructor.call(this, 'variable', line);
      this.name = false;
    }

    return Variable;

  })(Node);

  Constant = (function(superClass) {
    extend(Constant, superClass);

    function Constant(line) {
      Constant.__super__.constructor.call(this, 'constant', line);
      this.const_type = false;
      this.value = false;
    }

    return Constant;

  })(Node);

  remove_line_breaks = function(tokens) {
    var i;
    i = 0;
    while (i < tokens.length) {
      if (['line_break', 'block_end'].includes(tokens[i].type)) {
        tokens.splice(i--, 1);
      }
      i++;
    }
    return tokens;
  };

  binary_expression = function(stack) {
    var block, bracket_level, i, importance, j, left, node, pivot_importance, pivot_index, ref, right;
    stack = clone(stack);
    if (is_one_function_call(stack)) {
      return parse_function_call(stack);
    }
    if (is_one_array_call(stack)) {
      node = new ArrayCall(stack[0].at_line);
      node.name = stack[0].value;
      stack.pop();
      stack.shift();
      block = new Block(stack[0].at_line);
      block.children = parse_block(stack);
      node.index = block;
      return node;
    }
    if (is_one_array(stack)) {
      return parse_array(stack);
    }
    if (['line_break', 'block_end'].includes(stack[stack.length - 1].type)) {
      stack.pop();
    }
    pivot_index = -1;
    pivot_importance = Infinity;
    bracket_level = 0;
    for (i = j = 0, ref = stack.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      importance = operation_importance(stack[i].value) + OPERATORS.length * bracket_level;
      if (stack[i].type === 'binary_operator' && importance <= pivot_importance) {
        pivot_importance = importance;
        pivot_index = i;
      } else if (OPENERS.includes(stack[i].type)) {
        bracket_level += 1;
      } else if (CLOSERS.includes(stack[i].type)) {
        bracket_level -= 1;
      }
    }
    if (pivot_index > -1) {
      node = new BinaryExpression(stack[pivot_index].at_line, stack[pivot_index].value);
      left = stack.slice(0, pivot_index);
      right = stack.slice(pivot_index + 1, stack.length);
      if (left[0].type === 'open_parinthesis') {
        left.shift();
      }
      if (right[right.length - 1].type === 'close_parinthesis') {
        right.pop();
      }
      node.left = binary_expression(left);
      node.right = binary_expression(right);
    } else if (stack.length < 4) {
      node = parse_value(stack);
    }
    return node;
  };

  parse_value = function(tokens) {
    var i, node, token;
    if (tokens.length < 1) {
      throw error('Error trying to parse nothing as value.');
    }
    i = 0;
    while (i < tokens.length) {
      if (['open_parinthesis', 'close_parinthesis'].includes(tokens[i].type)) {
        tokens.splice(i, 1);
      } else {
        i++;
      }
    }
    if (tokens.length > 1) {
      console.log(tokens);
      throw error('parse error');
    }
    token = tokens[0];
    if (token.type === 'variable') {
      node = new Variable(token.at_line);
      node.name = token.value;
    } else if (['number', 'string', 'boolean'].includes(token.type)) {
      node = new Constant(token.at_line);
      node.const_type = token.type;
      node.value = token.value;
    } else {
      throw error('unexpected token ' + token.value + ' at line ' + token.at_line);
    }
    return node;
  };

  parse_array = function(tokens) {
    var block, node, stack;
    node = new ArrayLiteral(tokens[0].at_line);
    tokens.shift();
    tokens.pop();
    while (!(tokens.length < 1)) {
      stack = get_next_param(tokens);
      block = new Block(-1);
      block.children = parse_block(stack);
      node.items.push(block);
    }
    return node;
  };

  get_next_block = function(tokens) {
    var indent_levels, stack;
    stack = [];
    indent_levels = 0;
    while (!(indent_levels < 0 || tokens.length < 1)) {
      if (tokens[0].type === 'block_start' || tokens[0].type === 'block_continue') {
        indent_levels += 1;
      } else if (tokens[0].type === 'block_end') {
        indent_levels -= 1;
      }
      stack.push(tokens.shift());
    }
    return stack;
  };

  get_next_line = function(tokens) {
    var stack;
    stack = [];
    while (!(tokens.length < 1 || ['line_break', 'block_end'].includes(tokens[0].type))) {
      stack.push(tokens.shift());
    }
    return stack;
  };

  get_all_params = function(tokens) {
    var indent_levels, stack;
    stack = [];
    indent_levels = 0;
    while (!(indent_levels < 0 || tokens.length < 1)) {
      if (['open_parinthesis', 'function_call'].includes(tokens[0].type)) {
        indent_levels += 1;
      } else if (tokens[0].type === 'close_parinthesis') {
        indent_levels -= 1;
      }
      stack.push(tokens.shift());
    }
    return stack;
  };

  get_next_param = function(tokens) {
    var indent_levels, stack;
    stack = [];
    indent_levels = 0;
    while (!(tokens.length < 1 || (indent_levels <= 0 && tokens[0].type === 'comma'))) {
      if (OPENERS.includes(tokens[0].type)) {
        indent_levels += 1;
      } else if (CLOSERS.includes(tokens[0].type)) {
        indent_levels -= 1;
      }
      stack.push(tokens.shift());
    }
    if (tokens.length > 0 && tokens[0].type === 'comma') {
      tokens.shift();
    }
    return stack;
  };

  is_one_array = function(tokens) {
    var i, indent_levels, j, ref;
    tokens = clone(tokens);
    indent_levels = 0;
    for (i = j = 0, ref = tokens.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (OPENERS.includes(tokens[i].type)) {
        indent_levels += 1;
      } else if (CLOSERS.includes(tokens[i].type)) {
        indent_levels -= 1;
      }
      if (indent_levels < 1 && (0 < i && i < tokens.length - 1)) {
        return false;
      }
    }
    return tokens.length > 0 && tokens[0].type === 'open_brackets';
  };

  is_one_array_call = function(tokens) {
    var i, indent_levels, j, ref;
    tokens = clone(tokens);
    indent_levels = 0;
    for (i = j = 0, ref = tokens.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (OPENERS.includes(tokens[i].type)) {
        indent_levels += 1;
      } else if (CLOSERS.includes(tokens[i].type)) {
        indent_levels -= 1;
      }
      if (indent_levels < 1 && (0 < i && i < tokens.length - 1)) {
        return false;
      }
    }
    return tokens.length > 0 && tokens[0].type === 'array_call';
  };

  is_one_function_call = function(tokens) {
    var i, indent_levels, j, ref;
    tokens = clone(tokens);
    indent_levels = 0;
    for (i = j = 0, ref = tokens.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (['open_parinthesis', 'function_call'].includes(tokens[i].type)) {
        indent_levels += 1;
      } else if (tokens[i].type === 'close_parinthesis') {
        indent_levels -= 1;
      }
      if (indent_levels < 1 && (0 < i && i < tokens.length - 1)) {
        return false;
      }
    }
    return tokens.length > 0 && tokens[0].type === 'function_call';
  };

  parse_function_call = function(tokens) {
    var node, param;
    tokens = clone(tokens);
    if (tokens[tokens.length - 1].type === 'close_parinthesis') {
      tokens.pop();
    }
    node = new FunctionCall(tokens[0].at_line);
    node.name = tokens[0].value;
    tokens.shift();
    while (!(tokens.length < 1)) {
      param = get_next_param(tokens);
      node.params.push(binary_expression(param));
    }
    return node;
  };

  parse_block = function(tokens) {
    var end_stack, node, params, result, single, stack, start_stack;
    tokens = clone(tokens);
    stack = [];
    result = [];
    while (tokens.length > 0) {
      switch (tokens[0].type) {
        case 'block_start':

          /* IF CONDITIONAL */
          if (tokens[0].value === 'if') {
            node = new IfStatment(tokens[0].at_line);
            tokens.shift();
            single = new SingleIf(tokens[0].at_line);
            stack = get_next_line(tokens);
            single.test = binary_expression(stack);
            single.block = new Block(tokens[0].at_line);
            stack = get_next_block(tokens);
            single.block.children = parse_block(stack);
            node.blocks.push(single);
            while (tokens.length > 0 && ['block_continue'].includes(tokens[0].type)) {
              single = new SingleIf(tokens[0].at_line);
              if (tokens[0].value === 'else') {
                tokens.shift();
                single.test = new Constant(tokens[0].at_line);
                single.test.const_type = 'boolean';
                single.test.value = 'true';
                single.block = new Block(tokens[0].at_line);
                stack = get_next_block(tokens);
                single.block.children = parse_block(stack);
              } else if (tokens[0].value === 'else if') {
                tokens.shift();
                stack = get_next_line(tokens);
                single.test = binary_expression(stack);
                single.block = new Block(tokens[0].at_line);
                stack = get_next_block(tokens);
                single.block.children = parse_block(stack);
              }
              node.blocks.push(single);
            }
            result.push(node);

            /* WHILE LOOP */
          } else if (tokens[0].value === 'while') {
            node = new WhileLoop(tokens[0].at_line);
            tokens.shift();
            stack = get_next_line(tokens);
            node.test = binary_expression(stack);
            node.block = new Block(tokens[0].at_line);
            stack = get_next_block(tokens);
            node.block.children = parse_block(stack);
            result.push(node);

            /* FOR LOOP */
          } else if (tokens[0].value === 'for') {
            node = new ForLoop(tokens[0].at_line);
            tokens.shift();
            stack = get_next_line(tokens);
            if (stack[0].type === 'variable') {
              node.variable = stack[0].value;
            } else {
              throw error('Expected variable as first parameter on line ' + stack[0].at_line);
            }
            if (stack[1].value !== 'in') {
              throw error('For loop must follow format "for ... in [...]" on line ' + stack[0].at_line);
            }
            if (stack[2].type !== 'open_brackets') {
              throw error('For loop must have a range on line ' + stack[0].at_line);
            }
            stack.splice(0, 3);
            start_stack = [];
            while (stack[0].type !== 'range_seperator') {
              start_stack.push(stack.shift());
            }
            node.start = binary_expression(start_stack);
            if (stack[0].type !== 'range_seperator') {
              throw error('For loop range is missing start/end seperator on line ' + stack[0].at_line);
            }
            stack.shift();
            end_stack = [];
            while (stack[0].type !== 'close_brackets') {
              end_stack.push(stack.shift());
            }
            node.end = binary_expression(end_stack);
            stack = get_next_block(tokens);
            node.block = new Block(tokens[0].at_line);
            node.block.children = parse_block(stack);
            result.push(node);
          } else if (tokens[0].value === 'function') {
            node = new FunctionDefine(tokens[0].at_line);
            tokens.shift();
            if (tokens[0].type === 'function_call') {
              node.name = tokens.shift().value;
            } else {
              throw error('Function definition needs a name at line ' + tokens[0].at_line);
            }
            stack = get_all_params(tokens);
            if (stack[stack.length - 1].type === 'close_parinthesis') {
              stack.pop();
            }
            params = [];
            while (stack.length > 0) {
              params.push(binary_expression(get_next_param(stack)));
            }
            node.params = params;
            node.block = new Block(tokens[0].at_line);
            node.block.children = parse_block(get_next_block(tokens));
            result.push(node);
          }
          stack = [];
          continue;

          /* BLOCK CONTINUE */
        case 'block_continue':
          throw error('Block continue found by itself on line ' + tokens[0].at_line + '. Could be an "else" by without a matching "if"');

          /* BINARY EXPRESSION */
          break;
        case 'binary_operator':
        case 'function_call':
        case 'variable':
        case 'number':
        case 'string':
          while (!(tokens.length < 1 || tokens[0].type === 'line_break')) {
            stack.push(tokens.shift());
          }
          result.push(binary_expression(remove_line_breaks(stack)));
          stack = [];
          break;
        case 'include':
          stack = get_next_line(tokens);
          result.push(new Include(stack[1].at_line, stack[1].value));
          stack = [];
          break;
        default:
          stack.push(tokens.shift());
      }
    }
    return result;
  };

  parse = function(code) {
    var res;
    res = new Block(0);
    res.children = parse_block(code);
    return res;
  };

  module.exports = parse;

}).call(this);

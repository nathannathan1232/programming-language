// Generated by CoffeeScript 1.9.3
(function() {
  var ASSIGNMENT_OPERATORS, BOOLEAN_OPERATORS, Decimal, LOGICAL_OPERATORS, NUMERICAL_OPERATORS, Value, ValueArray, binary_operation, convert_value, error, is_truthy, more_than, similar;

  error = require('./error.js');

  Decimal = require('./decimal.js');

  Value = (function() {
    function Value(type, value, options) {
      var i;
      this.type = type;
      this.value = value;
      if (type === 'number') {
        this.value = new Decimal(value);
      }
      if (options) {
        for (i in options) {
          this[i] = options[i];
        }
      }
    }

    Value.prototype.is_value_object = function(v) {
      return typeof v === 'object' && v.hasOwnProperty('type') && v.hasOwnProperty('value') && true || false;
    };

    Value.prototype.ValueArray = ValueArray;

    return Value;

  })();

  ValueArray = (function() {
    function ValueArray(options) {
      var i;
      this.type = 'array';
      this.items = [];
      if (options) {
        for (i in options) {
          this[i] = options[i];
        }
      }
    }

    ValueArray.prototype.set_val = function(i, v) {
      return this.items[i] = v;
    };

    ValueArray.prototype.get_val = function(i) {
      if ((0 <= i && i <= this.items.length - 1)) {
        return this.items[i];
      } else {
        return new Value('boolean', false);
      }
    };

    ValueArray.prototype.push = function(v) {
      return this.items.push(v);
    };

    ValueArray.prototype.pop = function(v) {
      return this.items.pop();
    };

    return ValueArray;

  })();

  convert_value = function(v, type) {
    if (!Value.prototype.is_value_object(v)) {
      throw error(v);
    }
    if (v.type === type) {
      return v;
    }
    switch (v.type + '->' + type) {
      case 'number->string':
        return new Value('string', v.value.toString());
      case 'string->number':
        return new Value('number', v.value.toString());
      case 'boolean->number':
        return new Value('number', v.value === true ? 1 : 0);
      case 'number->boolean':
        return new Value('boolean', v.value.isZero() ? false : true);
      case 'string->boolean':
        return new Value('boolean', v.value === 'true' ? true : false);
      case 'boolean->string':
        return new Value('string', v.value.toString());
      default:
        throw error('Can not convert ' + v.type + ' to ' + type);
    }
  };

  is_truthy = function(v) {
    if (!Value.prototype.is_value_object(v)) {
      throw error(v);
    }
    switch (v.type) {
      case 'boolean':
        return v.value === true || v.value === 'true';
      case 'number':
        if (v.value.isZero()) {
          return false;
        } else {
          return true;
        }
        break;
      case 'string':
        if (v.value === '') {
          return false;
        } else {
          return true;
        }
    }
  };

  similar = function(a, b) {
    var na, nb;
    if (a.type === 'boolean' && b.type === 'number') {
      if ((b.value === '0' && a.value === false) || (b.value === '1' && a.value === true)) {
        return true;
      } else {
        return false;
      }
    }
    if (b.type === 'boolean' && a.type === 'number') {
      if ((a.value === '0' && b.value === false) || (a.value === '1' && b.value === true)) {
        return true;
      } else {
        return false;
      }
    }
    if (a.value === b.value) {
      return true;
    }
    na = convert_value(a, 'string').value;
    nb = convert_value(b, 'string').value;
    return na === nb;
  };

  more_than = function(a, b) {
    var chars, i, j, ref;
    chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    if (a.type === 'number' && b.type === 'number') {
      if (a.value.lessThanOrEqualTo(b.value)) {
        return false;
      } else {
        return true;
      }
    }
    a = convert_value(a, 'string').value;
    b = convert_value(b, 'string').value;
    if (a.length !== b.length) {
      return a.length > b.length;
    }
    for (i = j = 0, ref = a.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (chars.indexOf(a[i]) !== chars.indexOf(b[i])) {
        return chars.indexOf(a[i]) > chars.indexOf(b[i]);
      }
    }
    return false;
  };

  ASSIGNMENT_OPERATORS = ['=', ':=', '+=', '-=', '*=', '/=', '%=', '.='];

  NUMERICAL_OPERATORS = ['+', '-', '*', '/', '%', '|', '&', '**', '<<', '>>'];

  LOGICAL_OPERATORS = ['&&', '||', '^'];

  BOOLEAN_OPERATORS = ['<', '>', '>=', '<=', '!=', '~~'];

  binary_operation = function(a, b, op) {
    var na, nb;
    if (!Value.prototype.is_value_object(a || !Value.prototype.is_value_object(b))) {
      throw error('Invalid operation ' + op + ' on ' + a + ' and ' + b);
    }
    if (NUMERICAL_OPERATORS.includes(op)) {
      na = convert_value(a, 'number').value;
      nb = convert_value(b, 'number').value;
    }
    switch (op) {
      case '+':
        return new Value('number', na.add(nb));
      case '-':
        return new Value('number', na.minus(nb));
      case '*':
        return new Value('number', na.times(nb));
      case '/':
        return new Value('number', na.dividedBy(nb));
      case '%':
        return new Value('number', na.modulo(nb));
      case '**':
        return new Value('number', na.pow(nb));
      case '<<':
        return new Value('number', na.bitShift(nb));
      case '>>':
        return new Value('number', na.bitUnShift(nb));
      case '==':
        return new Value('boolean', similar(a, b));
      case '!=':
        return new Value('boolean', !similar(a, b));
      case '>':
        return new Value('boolean', more_than(a, b));
      case '>=':
        return new Value('boolean', more_than(a, b) || similar(a, b));
      case '<=':
        return new Value('boolean', !more_than(a, b));
      case '<':
        return new Value('boolean', !(more_than(a, b) || similar(a, b)));
      case '.':
        na = convert_value(a, 'string');
        nb = convert_value(b, 'string');
        return new Value('string', na.value + '' + nb.value);
      case '&&':
        if (is_truthy(a) && is_truthy(b)) {
          return b;
        } else {
          return new Value('boolean', false);
        }
        break;
      case '||':
        if (is_truthy(a)) {
          return a;
        } else {
          return b;
        }
      case '^':
        if (is_truthy(a) ^ is_truthy(b)) {
          if (is_truthy(a)) {
            return a;
          } else {
            return b;
          }
        } else {
          return new Value('boolean', false);
        }
        break;
      default:
        throw error('can not preform operation ' + op + ' between ' + a.type + ' and ' + b.type);
    }
  };

  module.exports = {
    NUMERICAL_OPERATORS: NUMERICAL_OPERATORS,
    ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS,
    BOOLEAN_OPERATORS: BOOLEAN_OPERATORS,
    binary_operation: binary_operation,
    is_truthy: is_truthy,
    convert_value: convert_value,
    Value: Value,
    ValueArray: ValueArray
  };

}).call(this);

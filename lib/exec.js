// Generated by CoffeeScript 1.9.3
(function() {
  var ASSIGNMENT_OPERATORS, Decimal, VariableList, error, exec, lib, load_module, run;

  error = require('./error.js');

  lib = require('./lib.js');

  Decimal = require('./decimal.js');

  ASSIGNMENT_OPERATORS = ['=', ':=', '+=', '-=', '*=', '/=', '%=', '.='];

  VariableList = (function() {
    function VariableList() {
      this.vars = [];
    }

    VariableList.prototype.get_var = function(name) {
      if (this.vars.hasOwnProperty(name)) {
        return this.vars[name];
      } else {
        throw error(name + ' is not defined!');
      }
    };

    VariableList.prototype.set_var = function(name, value) {
      return this.vars[name] = value;
    };

    VariableList.prototype.merge = function(scope) {
      var i, results;
      results = [];
      for (i in scope.vars) {
        if (scope.vars.hasOwnProperty(i)) {
          results.push(this.set_var(i, scope.vars[i]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return VariableList;

  })();

  load_module = function(filename, scope) {
    var f, i, m, results;
    m = require(filename);
    for (i in m.variables) {
      scope.set_var(i, m.variables[i]);
    }
    results = [];
    for (i in m.functions) {
      f = new lib.Value('function', 'native', {
        function_type: 'native',
        params: m.functions[i].params,
        block: m.functions[i].block
      });
      results.push(scope.set_var(i, f));
    }
    return results;
  };

  run = function(node, scope) {
    var arr, fn, i, index, j, k, l, len, local_scope, n, o, ref, ref1, ref2, ref3, ref4, res, value;
    switch (node.type) {
      case 'include':
        return load_module(node.name, scope);
      case 'block':
        ref = node.children;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          res = run(i, scope);
        }
        return res;
      case 'function-define':
        return scope.set_var(node.name, new lib.Value('function', 'local', {
          params: node.params,
          block: node.block
        }));
      case 'function-call':
        fn = scope.get_var(node.name);
        local_scope = new VariableList();
        local_scope.merge(scope);
        if (fn.value === 'local') {
          for (i = k = 0, ref1 = fn.params.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            local_scope.set_var(fn.params[i].name, run(node.params[i], scope));
          }
          return run(fn.block, local_scope);
        } else {
          for (i = l = 0, ref2 = fn.params.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
            local_scope.set_var(fn.params[i], run(node.params[i], scope));
          }
          return fn.block(local_scope);
        }
        break;
      case 'if':
        res = new lib.Value('boolean', false);
        for (i = n = 0, ref3 = node.blocks.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
          if (lib.is_truthy(run(node.blocks[i].test, scope))) {
            res = run(node.blocks[i].block, scope);
            break;
          }
        }
        return res;
      case 'while':
        res = new lib.Value('boolean', false);
        while (lib.is_truthy(run(node.test, scope))) {
          res = run(node.block, scope);
        }
        return res;
      case 'binary_expression':
        if (ASSIGNMENT_OPERATORS.includes(node.operator)) {
          if (node.left.type === 'variable') {
            if (node.operator === '=') {
              return scope.set_var(node.left.name, run(node.right, scope));
            } else {
              return scope.set_var(node.left.name, lib.binary_operation(scope.get_var(node.left.name), run(node.right, scope), node.operator.replace(/\=/, '')));
            }
          } else if (node.left.type === 'array_call') {
            arr = scope.get_var(node.left.name);
            index = run(node.left.index, scope).value.toString();
            if (node.operator === '=') {
              return arr.set_val(index, run(node.right, scope));
            } else {
              return arr.set_val(index, lib.binary_operation(arr.get_val(index), run(node.right, scope), node.operator.replace(/\=/, '')));
            }
          } else {
            console.log(node.left);
            throw error('Invalid expression on left side of assignment operator. Line ' + node.line);
          }
        } else {
          return lib.binary_operation(run(node.left, scope), run(node.right, scope), node.operator);
        }
        break;
      case 'array_literal':
        res = new lib.ValueArray();
        for (i = o = 0, ref4 = node.items.length; 0 <= ref4 ? o < ref4 : o > ref4; i = 0 <= ref4 ? ++o : --o) {
          res.push(run(node.items[i], scope));
        }
        return res;
      case 'array_call':
        arr = scope.get_var(node.name);
        index = run(node.index, scope);
        return arr.get_val(Number(index.value + ''));
      case 'variable':
        return scope.get_var(node.name);
      case 'constant':
        value = node.value;
        return new lib.Value(node.const_type, value);
    }
  };

  exec = function(code) {
    run(code, new VariableList());
    return console.log('---');
  };

  module.exports = exec;

}).call(this);
